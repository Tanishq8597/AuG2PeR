#! /usr/bin/env python3
# ROS imports
import rospy
from geometry_msgs.msg import Twist
from std_msgs.msg import Int32,Float32,Bool
from amr.msg import wheel

import controller

# Other imports
from math import pi,cos,sin
import odrive
from odrive.enums import *
import time
import sys

# Arguments from roslaunch
max_speed   = 5  #m/s
time_out    = 1  #s  
left_gain   = [5,1.75,0.0135] 
right_gain  = [6,1.5,0.0115]

class Motor_Driver:
    def __init__(self):
        self.linearVelocity  = 0
        self.angularVelocity = 0
        self.left_speed  = 0
        self.right_speed = 0 
        self.x = 0
        self.y = 0

        self.left_wheel = wheel()
        self.left_wheel.header.frame_id = "Left Wheel"
        self.left_wheel.header.seq = 0

        self.right_wheel = wheel()
        self.right_wheel.header.frame_id= "Right Wheel"
        self.right_wheel.header.seq = 0

        self.left_wheel_pub = rospy.Publisher("Left_Wheel",wheel,queue_size=1)
        self.right_wheel_pub= rospy.Publisher("Right_Wheel",wheel,queue_size=1)

        # Wait until board is detected
        odrive_board = odrive.find_any()

        rospy.init_node('diff_driver')
        # rospy.on_shutdown(self.Stop_Motor())
        Odrive_state_pub = rospy.Publisher("Odrive_state",Int32,queue_size=1)
        Odrive_state_pub.publish(1)

        self.a0 = odrive_board.axis0
        self.a1 = odrive_board.axis1

        self.a0.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        self.a1.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL

    def setup(self,maxMspeed):

        self.wheelSeparation = 0.48        #distance between wheel centers(m)
        self.wheelDiameter   = 166e-3      #m
        self.ticks_rev       = 90          #encoder ticks per revolution
        dist_per_rev         = pi*self.wheelDiameter
        self.rev_per_m       = 1/dist_per_rev  #1/pi*d
        self.twist_per_rev   = 2*dist_per_rev/self.wheelSeparation #theta(rad) = s/r (sector arc)
        self.maxMotorSpeed   = maxMspeed*self.rev_per_m   #rev/s 

        limits = [-self.maxMotorSpeed,self.maxMotorSpeed]
        # Safety timeouts
        self.timeout = time_out #s

        # cmd_vel subscriber
        rospy.Subscriber("cmd_vel",Twist,self.cmd_vel_CB)

        rate = rospy.Rate(50)
        self.last_vel_time = rospy.get_time()

        self.left_controller = controller.PID_controller_wheel("Left_wheel",limits,left_gain)
        self.right_controller = controller.PID_controller_wheel("Right_wheel",limits,right_gain)

        while not rospy.is_shutdown():
            self.Run()
            rate.sleep()

    def cmd_vel_CB(self,twist):
        self.linearVelocity = twist.linear.x*self.rev_per_m
        self.angularVelocity= twist.angular.z/self.twist_per_rev
        self.last_vel_time = rospy.get_time()
        

    def runMotor(self,linear,angular):

        self.left_speed = -(linear+angular*0.5*self.wheelSeparation)
        self.right_speed=  (linear-angular*0.5*self.wheelSeparation)

        encoder_time = rospy.get_time()

        dt = encoder_time - self.last_vel_time

        if dt > 1: dt = 0.1

        left_effort = self.left_controller.effort(self.left_speed,self.a0.encoder.vel_estimate,dt)
        right_effort= self.right_controller.effort(self.right_speed,self.a1.encoder.vel_estimate,dt)

        self.a0.controller.input_vel = self.left_speed + left_effort
        self.a1.controller.input_vel = self.right_speed+ right_effort


        self.left_wheel.header.stamp   = rospy.get_rostime()
        self.left_wheel.header.seq    += 1
        self.left_wheel.setpoint_speed = self.left_speed
        self.left_wheel.encoder_speed  = self.a0.encoder.vel_estimate
        self.left_wheel.PID_speed      = self.left_speed + left_effort
        self.left_wheel.dt             = dt  
        self.left_wheel_pub.publish(self.left_wheel)


        self.right_wheel.header.stamp = rospy.get_rostime()
        self.right_wheel.header.seq    += 1
        self.right_wheel.setpoint_speed = self.right_speed
        self.right_wheel.encoder_speed  = self.a1.encoder.vel_estimate
        self.right_wheel.PID_speed      = self.right_speed + right_effort
        self.right_wheel.dt             = dt  
        self.right_wheel_pub.publish(self.right_wheel)  

        self.odom()    

    def odom(self):
        V_L = self.left_wheel.PID_speed/self.rev_per_m
        V_R = self.right_wheel.PID_speed/self.rev_per_m
        dt  = (self.left_wheel.dt + self.right_wheel.dt)*0.5

        V         = 0.5*(V_R-V_L)
        omega_dot = (V_L+V_R)/self.wheelSeparation

        self.x += dt*V*cos(omega_dot*dt)
        self.y += dt*V*sin(omega_dot*dt)

        print(self.x,self.y)

    def Stop_Motor(self):
        self.runMotor(0,0)


    def Run(self):
        # Check for time out
        if rospy.get_time() - self.last_vel_time < self.timeout:
            self.runMotor(self.linearVelocity,self.angularVelocity)
        else:
            self.Stop_Motor()


if __name__ == '__main__':
    try:
        driving_node = Motor_Driver()
        driving_node.setup(max_speed)
    
    except rospy.ROSInterruptException:
        pass
        