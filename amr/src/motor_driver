#! /usr/bin/env python3
# ROS imports
import rospy
from geometry_msgs.msg import Twist
from std_msgs.msg import Int32,Float32,Bool

# Other imports
from math import pi
import odrive
from odrive.enums import *
import time
import sys


class Motor_Driver:
    def __init__(self):
        self.linearVelocity  = 0
        self.angularVelocity = 0
        self.left_speed  = 0
        self.right_speed = 0 
        # Wait until board is detected
        odrive_board = odrive.find_any()

        rospy.init_node('diff_drive_controller')
        # rospy.on_shutdown(self.Stop_Motor())
        Odrive_state_pub = rospy.Publisher("Odrive_state",Int32,queue_size=1)
        Odrive_state_pub.publish(1)

        self.a0 = odrive_board.axis0
        self.a1 = odrive_board.axis1

        self.one_run = 0

        # self.a0.controller.config.control_mode = CONTROL_MODE_VELOCITY_CONTROL
        # self.a1.controller.config.control_mode = CONTROL_MODE_VELOCITY_CONTROL

        self.a0.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        self.a1.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL

    def setup(self,maxMspeed):

        self.wheelSeparation = 0.48        #distance between wheel centers(m)
        self.wheelDiameter   = 166e-3      #m
        self.ticks_rev       = 90          #encoder ticks per revolution
        dist_per_rev         = pi*self.wheelDiameter
        self.rev_per_m       = 1/dist_per_rev  #1/pi*d
        self.twist_per_rev   = 2*dist_per_rev/self.wheelSeparation #theta(rad) = s/r (sector arc)
        self.maxMotorSpeed  = maxMspeed   #rev/s 
 
        # Safety timeouts
        self.timeout = 1 #s

        # cmd_vel subscriber
        rospy.Subscriber("cmd_vel",Twist,self.cmd_vel_CB)

        rate = rospy.Rate(50)
        self.last_vel_time = rospy.get_time()

        while not rospy.is_shutdown():
            self.Run()
            rate.sleep()

    def cmd_vel_CB(self,twist):
        self.linearVelocity = twist.linear.x*self.rev_per_m
        self.angularVelocity= twist.angular.z/self.twist_per_rev
        self.last_vel_time = rospy.get_time()
        

    def runMotor(self,linear,angular):
        # self.a0.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL
        # self.a1.requested_state = AXIS_STATE_CLOSED_LOOP_CONTROL

        self.left_speed = -(linear+angular*0.5*self.wheelSeparation)
        self.right_speed=  (linear-angular*0.5*self.wheelSeparation)

        if ~self.one_run:
            self.a0.controller.input_vel = self.left_speed
            self.a1.controller.input_vel = self.right_speed
            self.one_run = 1

        left_speed_pub = rospy.Publisher("Left_Wheel_speed",Float32,queue_size=1)
        right_speed_pub= rospy.Publisher("Right_Wheel_speed",Float32,queue_size=1)

        left_encoder_pub = rospy.Publisher("Left_Encoder",Float32,queue_size=1)
        right_encoder_pub= rospy.Publisher("Right_Encoder",Float32,queue_size=1)

        while rospy.get_time() - self.last_vel_time < 1 :
            # rospy.loginfo(rospy.get_time() - self.last_vel_time)
            left_speed_pub.publish(self.left_speed)
            left_encoder_pub.publish(self.a0.encoder.vel_estimate)
            right_speed_pub.publish(self.right_speed)
            right_encoder_pub.publish(self.a1.encoder.vel_estimate)

        

    def Stop_Motor(self):
        self.runMotor(0,0)
        # sys.exit(1)

    def Run(self):
        # Check for time out
        if rospy.get_time() - self.last_vel_time < self.timeout:
            self.runMotor(self.linearVelocity,self.angularVelocity)
        else:
            self.Stop_Motor()


if __name__ == '__main__':
    try:
        driving_node = Motor_Driver()
        driving_node.setup(2)
    
    except rospy.ROSInterruptException:
        pass
        